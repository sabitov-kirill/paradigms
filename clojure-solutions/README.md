#### Домашнее задание 9. Линейная алгебра на Clojure

1. Разработайте функции для работы с объектами линейной алгебры, которые представляются следующим образом:
    * скаляры – числа
    * векторы – векторы чисел;
    * матрицы – векторы векторов чисел.
2. Функции над векторами:
    * `v+`/`v-`/`v*`/`vd` – покоординатное сложение/вычитание/умножение/деление;
    * `scalar`/`vect` – скалярное/векторное произведение;
    * `v*s` – умножение на скаляр.
3. Функции над матрицами:
    * `m+`/`m-`/`m*`/`md` – поэлементное сложение/вычитание/умножение/деление;
    * `m*s` – умножение на скаляр;
    * `m*v` – умножение на вектор;
    * `m*m` – матричное умножение;
    * `transpose` – транспонирование;
4. **Сложный вариант.**
    1. Ко всем функциям должны быть указаны контракты. Например, нельзя складывать вектора разной длины.
    2. Все функции должны поддерживать произвольное число аргументов. Например `(v+ [1 2] [3 4] [5 6])` должно быть
       равно `[9 12]`.
5. При выполнении задания следует обратить внимание на:
    * Применение функций высшего порядка.
    * Выделение общего кода для операций.

#### Code Golf (бонус)

Правила

1. Выигрывает самая короткая программа. Длина программы считается после удаления незначимых пробелов.
2. Можно использовать произвольные функции [стандартной библиотеки](https://clojure.org/api/cheatsheet) Clojure.
3. Нельзя использовать функции Java и внешних библиотек.
4. Подача решений через чат. Решение должно быть корректно отформатировано и
   начинаться с `;Solution номинация длина`. Например, `;Solution det-3 1000`.

Номинации

* `det-3` — определитель матрицы за $O(n^3)$;
* `det-s` — определитель дольше чем за $O(n^3)$;
* `inv-3` — обратная матрица за $O(n^3)$;
* `inv-s` — обратная дольше чем за $O(n^3)$.

#### Домашнее задание 10. Функциональные выражения на Clojure

1. Разработайте функции `constant`, `variable`, `add`, `subtract`, `multiply`, `divide` и `negate` для представления
   арифметических выражений.
    1. Пример описания выражения `2x-3`:
        ```clojure
        (def expr
            (subtract 
                (multiply 
                    (constant 2)
                    (variable "x"))
                (constant 3)))        
        ```
    2. Выражение должно быть функцией, возвращающей значение выражения при подстановке переменных, заданных
       отображением. Например, `(expr {"x" 2})` должно быть равно 1.
2. Разработайте разборщик выражений, читающий выражения в стандартной для Clojure форме. Например,
   ```clojure
   (parseFunction "(- (\* 2 x) 3)")
   ```
   должно быть эквивалентно `expr`.
3. **Сложный вариант.** Функции `add`, `subtract`, `multiply` и `divide` должны принимать произвольное число аргументов.
   Разборщик так же должен допускать произвольное число аргументов для `+`, `-`, `*`, `/`.
4. При выполнении задания следует обратить внимание на:
    * Выделение общего кода для операций.

#### Домашнее задание 11. Объектные выражения на Clojure

1. Разработайте конструкторы `Constant`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide` и `Negate` для
   представления арифметических выражений.
    1. Пример описания выражения `2x-3`:
        ```clojure
        (def expr
            (Subtract
                (Multiply
                    (Constant 2)
                    (Variable "x")) 
                (Constant 3)))
        ```
    2. Функция `(evaluate expression vars)` должна производить вычисление выражения `expression` для значений
       переменных, заданных отображением `vars`. Например, `(evaluate expr {"x" 2})` должно быть равно 1.
    3. Функция `(toString expression)` должна выдавать запись выражения в стандартной для Clojure форме.
    4. Функция `(parseObject "expression")` должна разбирать выражения, записанные в стандартной для Clojure форме.
       Например,
       ```clojure
       (parseObject "(- (\* 2 x) 3)")
       ```
       должно быть эквивалентно `expr`.
2. **Сложный вариант.**
    1. Конструкторы `Add`, `Subtract`, `Multiply` и `Divide` должны принимать произвольное число аргументов. Парсер так
       же должен допускать произвольное число аргументов для `+`, `-`, `*`, `/`.
    2. Функция `(diff expression "variable")` должна возвращать выражение, представляющее производную исходного
       выражения по заданой перемененной. Например, `(diff expression "x")` должен возвращать выражение,
       эквивалентное `(Constant 2)`, при этом выражения `(Subtract (Constant 2) (Constant 0))` и
       ```clojure
       (Subtract
           (Add
               (Multiply (Constant 0) (Variable "x"))
               (Multiply (Constant 2) (Constant 1)))
           (Constant 0))
       ```
       так же будут считаться правильным ответом.
3. При выполнении задания можно использовать любой способ преставления объектов.
4. При выполнении задания можно использовать функции, для определения JS-like объектов, приведённые на лекции.

#### Домашнее задание 12. Комбинаторные парсеры

1. **Простой вариант.** Реализуйте функцию `(parseObjectPostfix "expression")`, разбирающую выражения, записанные в
   суффиксной форме, и функцию `toStringPostfix`, возвращающую строковое представление выражения в этой форме. Например,
    ```clojure
    (toStringPostfix (parseObjectPostfix "( ( 2 x \* ) 3 - )"))
    ```
   должно возвращать `((2 x *) 3 -)`.
2. **Сложный вариант.** Реализуйте функцию `(parseObjectInfix "expression")`, разбирающую выражения, записанные в
   инфиксной форме, и функцию `toStringInfix`, возвращающую строковое представление выражения в этой форме. Например,
    ```clojure
    (toStringInfix (parseObjectInfix "2 \* x - 3"))
    ```
   должно возвращать `((2 * x) - 3)`.
3. **Бонусный вариант.** Добавьте в библиотеку комбинаторов возможность обработки ошибок и продемонстрируйте ее
   использование в вашем парсере.
4. Функции разбора должны базироваться на библиотеке комбинаторов, разработанной на лекции.
