#### Домашнее задание 13. Простые числа на Prolog

1. Разработайте правила:

    * `prime(N)`, проверяющее, что `N` – простое число.
    * `composite(N)`, проверяющее, что `N` – составное число.
    * `prime_divisors(N, Divisors)`, проверяющее, что список `Divisors` содержит все простые делители числа `N`,
      упорядоченные по возрастанию. Если `N` делится на простое число `P` несколько раз, то `Divisors` должен содержать
      соответствующее число копий `P`.

2. Варианты

    * Простой: `N` ≤ 1000.
    * Сложный: `N` ≤ 105.
    * Бонусный: `N` ≤ 107.
3. Вы можете рассчитывать, на то, что до первого запроса будет выполнено правило `init(MAX_N)`.

#### Домашнее задание 14. Деревья поиска на Prolog

1. Реализуйте ассоциативный массив (map) на основе деревьев поиска. Для решения можно реализовать любое дерево поиска
   логарифмической высоты.
2. **Простой вариант.** Разработайте правила:

    * `map_build(ListMap, TreeMap)`, строящее дерево из упорядоченного списка пар ключ-значение ($O(n)$);
    * `map_get(TreeMap, Key, Value)`, проверяющее, что массив содержит заданную пару ключ-значение ($O(\log n)$).
3. **Сложный вариант.** Дополнительно разработайте правила:

    * `map_put(TreeMap, Key, Value, Result)`; добавляющее пару ключ-значение в массив, или заменяющее текущее значение
      для ключа ($O(\log n)$);
    * `map_remove(TreeMap, Key, Result)` удаляющее отображение для ключа ($O(\log n)$);
    * `map_build(ListMap, TreeMap)`, строящее дерево из **не**упорядоченного списка пар ключ-значение ($O(n \log n)$).

#### Домашнее задание 15. Разбор выражений на Prolog

1. Доработайте правило `evaluate(Expression, Variables, Result)`, вычисляющее арифметические выражения.
    1. Пример вычисления выражения `2(-x)-3` для `x = 5`:
        ```ijprolog
        evaluate(
            operation(op_subtract,
                operation(op_multiply,
                    const(2),
                    operation(op_negate, variable(x))
                ),
                const(3)
            ),
            [(x, 5)],
            -13
        )
        ```
    2. Поддерживаемые операции: сложение (`op_add`, `+`), вычитание (`op_subtract`, `-`),
       умножение (`op_multiply`, `*`), деление (`op_divide`, `/`), противоположное число (`op_negate`, `negate`).
2. **Простой вариант.** Реализуйте правило `suffix_str(Expression, Atom)`, разбирающее/выводящее выражения, записанные
   в [польской записи](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C).
   Например,
    ```ijprolog
    polish_str(
        operation(op_subtract,
            operation(op_multiply,
                const(2),
                operation(op_negate, variable(x))
            ),
            const(3)
        ),
        '- \* 2 negate x 3'
    )
    ```

3. **Сложный вариант.** Реализуйте правило `infix_str(Expression, Atom)`, разбирающее/выводящее выражения, записанные в
   полноскобочной инфиксной форме. Например,
    ```ijprolog
    infix_str(
        operation(op_subtract,
            operation(op_multiply,
                const(2),
                operation(op_negate, variable(x))
            ),
            const(3)
        ),
        '((2 \* negate x) - 3)'
    )
    ```

4. Правила должны быть реализованы с применением DC-грамматик.
